geom_node_point(aes())
g + theme_graph()
bus_graph=bus_graph%>%mutate(betweenness_centrality = centrality_betweenness(normalized = T)) %>%mutate(closeness_centrality = centrality_closeness(normalized = T))%>%mutate(centrality_degree=centrality_degree(mode='out',normalized = T))%>%mutate(centrality_eigen=centrality_eigen(weights=bus_graph$Frequency,directed=T))
knitr::opts_chunk$set(echo = TRUE)
packages = c('igraph','ggraph','tidygraph','visNetwork', 'lubridate', 'tidyverse','ggmap','visNetwork', 'lubridate', 'tidyverse', 'ggplot2', 'leaflet', 'ggiraph', 'sf', 'tmap','assertthat','purrr','sf','tmap','rgdal','networkD3','RColorBrewer','seriation', 'dendextend', 'heatmaply','flows','sp')
for(p in packages){library
if(!require(p, character.only = T)){
install.packages(p)
}
library(p, character.only = T)
}
# igraph is not needed in this tutorial since tidygraph and ggraph has dependencies from igraph
## Ggraph for static
## visNetwork for interactive graph
## Lubridate belongs to tidyverse. But in tidyverse, it is not included when installing tidyverse. Lubridate designed to handle date data. Convert datetime field to extract, date, time, month.
busstops <- read_csv('data/busstop_lonlat_subzone_District.csv') %>%
mutate(subzone_name = toupper(subzone_name)) #capitalise the column in subzone
busstops$BusStopCode <- as.character(busstops$BusStopCode)
#filter(planning_area == 'QUEENSTOWN')
# busstops <- busstops[busstops$BusStopCode %in% as.list(unique(busroute['BusStopCode']))[['BusStopCode']], ]
busstops
busroute <- read_csv('data/bus_route_overall.csv')
busroute_data <- read_csv('data/bus_route_overall.csv')
busroute <- busroute_data
busroute$BusStopCode <- as.character(busroute$BusStopCode)
busroute <- busroute[c('BusStopCode', 'Direction', 'Distance', 'ServiceNo', 'StopSequence')]
#%>%dplyr::filter(ServiceNo %in% top_bus)
busroute <- busroute[busroute$BusStopCode %in% as.list(unique(busstops['BusStopCode']))[['BusStopCode']], ]
busroute
# testing
a<- as.list(unique(busroute['BusStopCode']))[['BusStopCode']]
length(a)
busroute_2 <- busroute
busroute_2['StopSequence'] = busroute_2['StopSequence']-1
busroute_2['BusStopCode_dest'] = busroute_2['BusStopCode']
busroute_2 <- busroute_2[c('BusStopCode_dest', 'Direction', 'ServiceNo', 'StopSequence')]
busstops_from_to <- dplyr::inner_join(busroute, busroute_2, by =c('StopSequence', 'ServiceNo', 'Direction'))
busstops_from_to
#join the two tables together
# to from to the id
busroute_busstop <- dplyr::inner_join(busstops_from_to, busstops, by ='BusStopCode')
keeps <- c('BusStopCode', 'BusStopCode_dest', 'Direction', 'Distance', 'ServiceNo', 'Latitude', 'Longitude', 'planning_area', 'subzone_name','district')
busroute_busstop <- busroute_busstop[, keeps, drop = FALSE] %>%
rename(from = BusStopCode) %>%
rename(to = BusStopCode_dest)
head(busroute_busstop)
busroute_busstop_aggregated <- busroute_busstop %>%
group_by(from, to) %>%  # , planning_area
summarise(Weight = n()) %>%
filter(from!=to) %>%
filter(Weight > 1) %>%
ungroup()
busroute_busstop_aggregated$from <- as.character(busroute_busstop_aggregated$from)
busroute_busstop_aggregated$to <- as.character(busroute_busstop_aggregated$to)
busroute_busstop_aggregated
total <- busstops %>%
rename(id = BusStopCode)
total$id <- as.character(total$id)
total
bus_graph <- tbl_graph(nodes = total, edges = busroute_busstop_aggregated, directed = TRUE)
#%>%
#          activate(edges) %>%
#          arrange(desc(Weight))
#%>%
#         filter(id %in% union(.E()$to, .E()$from))
bus_graph
# bus_graph %>%
#   activate(edges) %>%
#   arrange(desc(Weight))
g <- ggraph(bus_graph) +
geom_edge_link(aes()) +
geom_node_point(aes())
g + theme_graph()
bus_graph=bus_graph%>%mutate(betweenness_centrality = centrality_betweenness(normalized = T)) %>%mutate(closeness_centrality = centrality_closeness(normalized = T))%>%mutate(centrality_degree=centrality_degree(mode='out',normalized = T))%>%mutate(centrality_eigen=centrality_eigen(weights=bus_graph$Frequency,directed=T))
bus_graph
mpsz <- st_read(dsn = "data/geospatial",
layer = "MP14_SUBZONE_WEB_PL")
mpsz
map <- qtm(mpsz)
#register_google(key = ) #create your own key
register_google(key = "AIzaSyAVz4L7AGlC88pfMCHpxgKNH9hle3gxW9o")
map <- get_map(location = c(lon = 103.8279248, lat = 1.3438295), zoom=11, source = "google", maptype = 'roadmap')
p <- ggmap(map)
p
library(rgdal)     # R wrapper around GDAL/OGR
library(ggplot2)   # for general plotting
library(ggmap)    # for fortifying shapefiles
# First read in the shapefile, using the path to the shapefile and the shapefile name minus the
# extension as arguments
shapefile <- readOGR("data/geospatial", "MP14_SUBZONE_WEB_PL")
# Next the shapefile has to be converted to a dataframe for use in ggplot2
shapefile_df <- fortify(shapefile)
# Now the shapefile can be plotted as either a geom_path or a geom_polygon.
## This is to draw the shape file of Singapore outline
map_gg2 <- geom_polygon(data = shapefile_df,
aes(x = long, y = lat, group = group),
color = 'gray', fill = 'gray', size = .2)
map_gg3 <- geom_path(data = shapefile_df,
aes(x = long, y = lat, group = group),
color = 'red', fill = 'red', size = .2)
map_gg4 <- ggplot() + map_gg2+ map_gg3 +geom_point() +
annotate("point", x = 31596, y = 29220, colour = "blue")
print(map_gg4)
##print(map_ggg)
G=bus_graph
#Normally we need to create two vectors in order to plot both the network data and the coordinates on a map
#plot_vector takes the longitude and latitude to be plotted on a map.
#plot_vector1 takes the lon, lat and the network centrality values.
plot_vector<- as.data.frame(cbind(V(G)$Longitude,V(G)$Latitude))
plot_vector1<- as.data.frame(cbind(V(G)$Longitude,V(G)$Latitude,V(G)$betweenness_centrality,V(G)$closeness_centrality))
#we are taking the edgelist which is being used to get the origin and destination of the airport data.
#edgelist[,1]- takes the origin values and the edgelist[,2] takes the destination values.
edgelist <- get.edgelist(G)
edgelist[,1]<-as.numeric(match(edgelist[,1],V(G)))
edgelist[,2]<-as.numeric(match(edgelist[,2],V(G)))
#the edges now consists of the edge between the origin and the destination values
edges <- data.frame(plot_vector[edgelist[,1],], plot_vector1[edgelist[,2],])
#naming the coloumns obtained to plot
colnames(edges) <- c("X1","Y1","X2","Y2")
#Here we are taking ggmap as our base layer. on top of ggmap we are plotting the origin and destination coordinates using the plot_vector as our 2nd layer, then we are plotting the coordinates of all the centrality from the plot_vector1 as our 3rd layer and then we are ploting the geom_segment i.e. the edges as our 4th layer.
plot_vector1
V(G)$betweenness_centrality
# V1
map <- get_map(location = c(lon = 103.7662684, lat = 1.2869421), zoom=14, source = "google", maptype = 'roadmap') #maptype = 'toner'
p <- ggmap(map)
z=p +
geom_segment(aes(x=X1, y=Y1, xend = X2, yend = Y2), color='black',data=edges,arrow = arrow(length = unit(0.2,"cm")))+
#geom_point(aes(V1, V2), data=plot_vector1)+
geom_point(aes(x=V1,y=V2,size=plot_vector1$V3,colour=plot_vector1$V4),plot_vector1)+
scale_colour_gradientn(colours=rainbow(5))+scale_size_continuous(range = c(1, 10))
z
#we use the node3 to get our origin and destination airport for plotting it on our map
node1=data.frame(plot_vector1[edgelist[,1],])
node2=data.frame(plot_vector1[edgelist[,2],])
node3=data.frame(cbind(node1,node2))
#Then we use a for loop in order to put the destination and origin airport on to the leaflet
map3 = leaflet(node3) %>%
addProviderTiles("CartoDB", group = "CartoDB") %>%
addTiles()
for(i in 1:nrow(node3)){
map3 <- addPolylines(map3, lat = as.numeric(node3[i, c(2, 6)]),
lng = as.numeric(node3[i, c(1, 5)]))
#origin
map3<-addCircleMarkers(map3, lat = as.numeric(node3[i, 2]),
lng = as.numeric(node3[i,1]),radius =(as.numeric(node3[i, 4]))*100,color='red')
#destination
map3<-addCircleMarkers(map3, lat = as.numeric(node3[i, 6]),
lng = as.numeric(node3[i, 5]),radius =(as.numeric(node3[i, 8]))*100,color='red' )
}
map3
map <- get_map(location = c(lon = 103.7662684, lat = 1.2869421), zoom=14, source = "google", maptype = 'watercolor')
bus_graph$layout=cbind(V(bus_graph)$Longitude,V(bus_graph)$Latitude)
#arrow formating
a <- arrow(type = "closed", length = unit(.09, "inches"))
#from the below code we are telling ggmap to take ggraph as your base layer with layout as the cordinates.
#Here we get the curvature using geom_edge_arc.
g_1<-ggmap(map, fullpage = TRUE, base_layer = ggraph(bus_graph)) +
geom_edge_arc(aes(edge_size=E(bus_graph)$centrality_degree),edge_colour = 'red', edge_alpha = 0.5,curvature = 0.2, arrow=a, end_cap = circle(.008, 'inches')) +
geom_node_point(aes(colour = closeness_centrality,size=betweenness_centrality))+ scale_colour_gradientn(colours=rainbow(3))+scale_size_continuous(range = c(1, 10))
plot(g_1)
SZ <- read_csv("data/subzoneData.csv") %>%
rename(subzone_name = SUBZONE_N)
busstops <- read_csv('data/busstop_lonlat_subzone_district.csv') %>%
mutate(subzone_name = toupper(subzone_name)) #capitalise the column in subzone
busstops <- busstops %>% select(c('subzone_name','BusStopCode','district'))
# Now inner join the 2 tables so i can find the weights
node <- dplyr::inner_join(busstops, SZ, by =c('subzone_name')) %>%
select(c('OBJECTID','district','subzone_name','X_ADDR','Y_ADDR'))%>%
group_by(OBJECTID,subzone_name,district,X_ADDR,Y_ADDR) %>%
summarise(weight = n()) %>%
# filter(weight > 1) %>%
ungroup()  %>%
rename(id = OBJECTID) %>%
rename(name = subzone_name)%>%
rename(x = X_ADDR) %>%
rename(y = Y_ADDR)
node
# d <- data.frame(lon=node$lon, lat=node$lat)
# coordinates(d) <- c("lon", "lat")
# proj4string(d) <- CRS("+init=epsg:4326") # WGS 84
# CRS.new <- CRS("+proj=tmerc +lat_0=1.366666666666667 +lon_0=103.8333333333333 +k=1 +x_0=28001.642 +y_0=38744.572 +ellps=WGS84 +units=m +no_defs")
# # (@mdsumner points out that
# #    CRS.new <- CRS("+init=epsg:2056")
# # will work, and indeed it does. See http://spatialreference.org/ref/epsg/2056/proj4/.)
# d.ch1903 <- spTransform(d, CRS.new)
# par(mfrow=c(1,3))
# plot(d, axes=TRUE, main="Original lat-lon", cex.axis=.95)
# plot(d.ch1903, axes=TRUE, main="Projected", cex.axis=.95)
# unclass(d.ch1903)
#
# d.ch1903
# nodes_XY <- cbind(node$id,node$name,coordinates(d.ch1903),node$weight)
# # names(nodes_XY)[1] <- 'id'
# # names(nodes_XY)[2] <- 'name'
# # names(nodes_XY)[3] <- 'lon'
# # names(nodes_XY)[4] <- 'lat'
# # names(nodes_XY)[5] <- 'weight'
# class(nodes_XY)
# nodes_XY_df <- as.data.frame(nodes_XY) %>%
#   rename(id = V1) %>%
#   rename(name = V2) %>%
#   rename(weight = V5)
edges_data <- read_csv("data/origin_dest_cleaned_jy.csv")
edges <- edges_data
#%>%
#   select(-c('YEAR_MONTH','PT_TYPE','ORIGIN_PT_CODE','DESTINATION_PT_CODE','RoadName_Origin','Description_Origin','RoadName_Destination','Description_Destination'))
# we need to append "subzone_origin" and "subzone_dest" so we can calculate weights based on busstops in these subzones
edges_join <- merge(edges, busstops, by.x='BusStopCode_x', by.y = 'BusStopCode') %>%
rename(subzone_ori = subzone_name)
edges_join2 <- merge(edges_join, busstops, by.x='BusStopCode_y', by.y = 'BusStopCode') %>%
rename(subzone_dest = subzone_name)
# remove the intermediate dataframe from cache
remove(edges_join)
remove(edges)
edges <- edges_join2 %>%
#select('subzone_ori','subzone_dest') %>%
rename(from =subzone_ori) %>%
rename(to = subzone_dest) %>%
# Group by "from","to" and add the "DAY_TYPE" so we can choose in RShiny
group_by(from,to,DAY_TYPE) %>%
arrange(X1) %>%
# make weights to be according to "TOTAL_TRIPS"
summarise(weight = sum(TOTAL_TRIPS))%>%
# filter(weight>1) %>%
ungroup()
# add a column for category so it fit into the online model
edges <- cbind(edges,category=1)
get_index = node %>% select(c('id','name'))
edge_id <- merge(edges, get_index, by.x = "from", by.y = "name") %>%
select(-c("from")) %>%
rename(from=id)
edge_id2 <- merge(edge_id, get_index, by.x = "to", by.y = "name") %>%
select(-c("to")) %>%
rename(to=id)
# https://github.com/nicolewhite/neo4j-alchemy-cluster/issues/2
#yes it matches in ID
edge_id2[which(! edge_id2$from %in% node$id) ,]
edge_id2[which(! edge_id2$to %in% node$id) ,]
edge_id2$to <- as.character(edge_id2$to)
edge_id2$from <- as.character(edge_id2$from)
edge_id2 <- edge_id2 %>%
select(c('from','to','DAY_TYPE','weight','category'))
# change node id also to as.character
node$id <- as.character(node$id)
# https://igraph.org/r/doc/graph_from_data_frame.html
g <- graph_from_data_frame(edge_id2, directed = TRUE, vertices = node)
edges_for_plot <- edge_id2 %>%
inner_join(node %>% select(id, x, y), by = c('from' = 'id')) %>%
inner_join(node %>% select(id, x, y), by = c('to' = 'id'))
assert_that(nrow(edges_for_plot) == nrow(edge_id2))
node$weight = degree(g)
maptheme <- theme(panel.grid = element_blank()) +
theme(axis.text = element_blank()) +
theme(axis.ticks = element_blank()) +
theme(axis.title = element_blank()) +
theme(legend.position = "bottom") +
theme(panel.grid = element_blank()) +
theme(panel.background = element_rect(fill = "#596673")) +
theme(plot.margin = unit(c(0, 0, 0.5, 0), 'cm'))
node_pos <- node %>%
select(x, y)  # node positions must be called x, y
lay <- create_layout(g, 'manual',
node.positions = node_pos)
assert_that(nrow(lay) == nrow(node))
lay <- lay[ -c(1,2) ]
# add node degree for scaling the node sizes
lay$weight <- degree(g)
# We pass the layout lay and use ggraphâ€™s geoms geom_edge_arc and geom_node_point for plotting:
# convert all columns to numeric
# https://stackoverflow.com/questions/19146354/batch-convert-columns-to-numeric-type
edges_for_plot4 <- edges_for_plot %>%
select(c('from','to','DAY_TYPE','weight','category','x.x','y.x','x.y','y.y')) %>%
rename(x = x.x) %>%
rename(y = y.x) %>%
rename(xend = x.y) %>%
rename(yend = y.y)
edges_for_plot4$x    <- as.numeric(as.character(edges_for_plot4$x))
edges_for_plot4$y    <- as.numeric(as.character(edges_for_plot4$y))
edges_for_plot4$xend <- as.numeric(as.character(edges_for_plot4$xend))
edges_for_plot4$yend <- as.numeric(as.character(edges_for_plot4$yend))
lay$x <-  as.numeric(as.character(lay$x))
lay$y <-  as.numeric(as.character(lay$y))
edge_id2$to <- as.character(edge_id2$to)
edge_id2$from <- as.character(edge_id2$from)
edge_id2 <- edge_id2 %>%
select(c('from','to','DAY_TYPE','weight','category'))
edges_for_plot4 <- edges_for_plot4 %>%
mutate(
bin = cut(weight, seq(0,max(edges_for_plot4$weight),2), na.rm=TRUE)) %>%
ungroup()
# https://stackoverflow.com/questions/54943114/how-to-create-bins-in-r
# plot of graph starts here
map <- ggplot(lay) + map_gg2+ map_gg3 +# ggraph(lay)
geom_edge_arc(aes(edge_width = weight,   # draw edges as arcs
circular = FALSE,show.legend = TRUE),
data = edges_for_plot4, curvature = 0.33,
alpha = 0.5) +
scale_edge_width_continuous(range = c(0.5,50),             # scale for edge widths
guide = FALSE) +
geom_node_point(aes(size = weight),show.legend = FALSE, shape = 21,            # draw node
fill = "white", color = "black",
stroke = 0.5) +
scale_size_continuous(range = c(1, 10), guide = FALSE) +    # scale for node sizes
geom_node_text(aes(label = name),show.legend = FALSE, repel = TRUE, size = 5,
color = "white", fontface = "bold") +
maptheme
# https://ggplot2.tidyverse.org/reference/geom_polygon.html
map
ggraph(lay) + map_gg2  +
geom_edge_arc(aes(color = bin,edge_width = weight,   # draw edges as arcs
circular = FALSE),
data = edges_for_plot4, curvature = 0.33,
alpha = 0.5, show.legend= FALSE) +
scale_edge_width_continuous(range = c(0.5, 5)) + maptheme
ggraph(lay) + map_gg2 +
geom_node_point(aes(size = weight),shape = 21,
fill = "white", color = "black",
stroke = 0.5)
node_inter <- node %>%
select(-c("id")) %>%
rename(id = name)
edges_inter <- edges_join2 %>%
#select('subzone_ori','subzone_dest') %>%
rename(from =subzone_ori) %>%
rename(to = subzone_dest) %>%
# Group by "from","to" and add the "DAY_TYPE" so we can choose in RShiny
group_by(from,to,DAY_TYPE) %>%
arrange(X1) %>%
# make weights to be according to "TOTAL_TRIPS"
summarise(weight = sum(TOTAL_TRIPS))%>%
filter(weight>1) %>%
ungroup() %>%
drop_na()
edges_inter <- edges_inter %>%
rename(value = weight)
node_inter <- node_inter %>%
rename(value = weight) %>%
rename(group = district)
print(unique(edges_inter[which(! edges_inter$from %in% node_inter$id) ,]))
print(unique(edges_inter[which(! edges_inter$to %in% node_inter$id) ,]))
print(unique(edges_for_plot4[which(! edges_for_plot4$from %in% node$id) ,]))
print(unique(edges_for_plot4[which(! edges_for_plot4$to %in% node$id) ,]))
visNetwork(node_inter, edges_inter,width = "150%") %>%
visIgraphLayout(layout = "layout_with_fr") %>%
visEdges(arrows = "to", smooth = list(enabled = TRUE, type = "curvedCW", min=2, max= 300)) %>%
visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%
visInteraction(navigationButtons = TRUE) %>%
visLegend()
# sankey <- sankeyNetwork(Links = edges_inter, Nodes = node_inter, Source = 'from', Target = 'to',
#               Value = 'value', NodeID = 'id', fontSize = 16)
# sankey <- htmlwidgets::prependContent(sankey, htmltools::tags$h1("Interactive Sankey flow Origin to Destination by PA"))
# sankey
sankey <- sankeyNetwork(Links = edges_for_plot4, Nodes = node, Source = 'from', Target = 'to',
Value = 'weight', NodeID = 'id', fontSize = 16)
sankey <- htmlwidgets::prependContent(sankey, htmltools::tags$h1("Interactive Sankey flow Origin to Destination by PA"))
sankey
# rb, subset
edges_for_plot4_rb <- edges_for_plot4 %>%
filter(DAY_TYPE == "WEEKDAY") %>%
filter(from == '5')
edges_for_plot4_rb$from    <- as.numeric(edges_for_plot4_rb$from)
edges_for_plot4_rb$to    <- as.numeric(edges_for_plot4_rb$to)
edges_for_plot4_rb
node_rb <- node
node_rb$id <- as.numeric(node_rb$id)
node_rb
#class(node_rb)
#class(edges_for_plot4_rb)
sankey <- sankeyNetwork(Links = edges_for_plot4_rb, Nodes = node_rb, Source = 'from', Target = 'to',
Value = 'weight', NodeID = 'name', fontSize = 16)
sankey <- htmlwidgets::prependContent(sankey, htmltools::tags$h1("Interactive Sankey flow Origin to Destination by PA"))
sankey
# https://stackoverflow.com/questions/51503328/removing-unused-nodes-in-sankey-network
flow <- edges_data %>%
select('DAY_TYPE','TIME_PER_HOUR','BusStopCode_x','BusStopCode_y','TOTAL_TRIPS') %>%
unite(from_to, BusStopCode_x,BusStopCode_y, sep = "_", remove=FALSE) %>%
group_by(from_to) %>%
summarise(Frequency = sum(TOTAL_TRIPS))%>%
separate(from_to, c("from", "to"))
# Prepare data
myflows <- prepflows(mat = flow, i = "from", j = "to", fij = "Frequency")
myflows[1:4,1:4]
# Get statistics about the matrix
statmat(mat = myflows, output = "none", verbose = TRUE)
# Remove the matrix diagonal
diag(myflows) <- 0
# Selection of flows > 500
flowSel1 <- firstflowsg(mat = myflows, method = "xfirst", k = 5000)
# Selection of flows > 1000
flowSel2 <- firstflowsg(mat = myflows, method = "xfirst", k = 10000)
# Compare initial matrix and selected matrices
compmat(mat1 = myflows, mat2 = myflows * flowSel1, digits = 1)
compmat(mat1 = myflows, mat2 = myflows * flowSel2, digits = 1)
# Remove the matrix diagonal
diag(myflows) <- 0
# Select flows that represent at least 20% of the sum of outgoing flows for
# each urban area. ( can select other methods )
flowSel1 <- firstflows(mat = myflows/rowSums(myflows)*100, method = "xfirst",
k = 20)
# Select the dominant flows (incoming flows criterion)
flowSel2 <- domflows(mat = myflows, w = colSums(myflows), k = 1)
# Combine selections
flowSel <- myflows * flowSel1 * flowSel2
# Node weights
inflows <- data.frame(id = colnames(myflows), w = colSums(myflows))
wh_heatmap <- heatmap(flowSel[0:5000,0:5000],
scale="column",
cexRow = 0.6,
cexCol = 0.8,
margins = c(10, 4))
busroute_2 <- busroute
busroute_2['StopSequence'] = busroute_2['StopSequence']-1
busroute_2['BusStopCode_dest'] = busroute_2['BusStopCode']
busroute_2 <- busroute_2[c('BusStopCode_dest', 'Direction', 'ServiceNo', 'StopSequence')]
busstops_from_to <- dplyr::inner_join(busroute, busroute_2, by =c('StopSequence', 'ServiceNo', 'Direction'))
busstops_from_to
busEdge <- busstops_from_to %>%
select(`BusStopCode`, `BusStopCode_dest`) %>%
mutate(from= `BusStopCode`) %>%
mutate(to = `BusStopCode_dest`) %>%
select(`from`, `to`)
busNode <- busNode %>%
select(`BusStopCode`, `Latitude`, `Longitude`)
shiny::runApp('C:/Users/jia yi/Desktop/MITB/Sem2/ISSS608 Visual Analytics and its applications/Project/RShiny/ProjRShiny_jiayi')
runApp('C:/Users/jia yi/Desktop/MITB/Sem2/ISSS608 Visual Analytics and its applications/Project/RShiny/ProjRShiny_jiayi')
runApp('C:/Users/jia yi/Desktop/MITB/Sem2/ISSS608 Visual Analytics and its applications/Project/RShiny/ProjRShiny_jiayi')
runApp('C:/Users/jia yi/Desktop/MITB/Sem2/ISSS608 Visual Analytics and its applications/Project/RShiny/ProjRShiny_jiayi')
runApp()
runApp()
runApp('C:/Users/jia yi/Desktop/MITB/Sem2/ISSS608 Visual Analytics and its applications/Project/RShiny/ProjRShiny_jiayi')
runApp('C:/Users/jia yi/Desktop/MITB/Sem2/ISSS608 Visual Analytics and its applications/Project/RShiny/ProjRShiny_jiayi')
runApp('C:/Users/jia yi/Desktop/MITB/Sem2/ISSS608 Visual Analytics and its applications/Project/RShiny/ProjRShiny_jiayi')
View(data)
runApp('C:/Users/jia yi/Desktop/MITB/Sem2/ISSS608 Visual Analytics and its applications/Project/RShiny/ProjRShiny_jiayi')
View(edges_SZ)
View(map_gg4_SZ)
runApp('C:/Users/jia yi/Desktop/MITB/Sem2/ISSS608 Visual Analytics and its applications/Project/RShiny/ProjRShiny_jiayi')
shiny::runApp('C:/Users/jia yi/Desktop/MITB/Sem2/ISSS608 Visual Analytics and its applications/Project/RShiny/ProjRShiny_jiayi')
runApp('C:/Users/jia yi/Desktop/MITB/Sem2/ISSS608 Visual Analytics and its applications/Project/RShiny/ProjRShiny_jiayi')
runApp('C:/Users/jia yi/Desktop/MITB/Sem2/ISSS608 Visual Analytics and its applications/Project/RShiny/ProjRShiny_jiayi')
runApp('C:/Users/jia yi/Desktop/MITB/Sem2/ISSS608 Visual Analytics and its applications/Project/RShiny/ProjRShiny_jiayi')
runApp('C:/Users/jia yi/Desktop/MITB/Sem2/ISSS608 Visual Analytics and its applications/Project/RShiny/ProjRShiny_jiayi')
runApp('C:/Users/jia yi/Desktop/MITB/Sem2/ISSS608 Visual Analytics and its applications/Project/RShiny/ProjRShiny_jiayi')
runApp()
shiny::runApp('C:/Users/jia yi/Desktop/MITB/Sem2/ISSS608 Visual Analytics and its applications/Project/RShiny/ProjRShiny_jiayi')
runApp('C:/Users/jia yi/Desktop/MITB/Sem2/ISSS608 Visual Analytics and its applications/Project/RShiny/ProjRShiny_jiayi')
passVOl <- read_csv("data/passenger volume by busstop.csv") %>% rename(BusStopCode)
# centrality dataset
central <- read_csv("data/centralityTable.csv")
pass_central <- inner_join(passVol, central, by = "BusStopCode")
passVol <- read_csv("data/passenger volume by busstop.csv") %>% rename(BusStopCode)
# centrality dataset
central <- read_csv("data/centralityTable.csv")
pass_central <- inner_join(passVol, central, by = "BusStopCode")
passVol <- read_csv("data/passenger volume by busstop.csv") %>% rename(BusStopCode)
########################### Data Prep JY #############################
# passenger volume per busstops
passVol <- read_csv("data/passenger volume by busstop.csv") %>% rename(BusStopCode = PT_CODE)
runApp('C:/Users/jia yi/Desktop/MITB/Sem2/ISSS608 Visual Analytics and its applications/Project/RShiny/ProjRShiny_jiayi')
########################### Data Prep JY #############################
# passenger volume per busstops
passVol <- read_csv("data/passenger volume by busstop.csv")
shiny::runApp('C:/Users/jia yi/Desktop/MITB/Sem2/ISSS608 Visual Analytics and its applications/Project/RShiny/ProjRShiny_jiayi')
runApp('C:/Users/jia yi/Desktop/MITB/Sem2/ISSS608 Visual Analytics and its applications/Project/RShiny/ProjRShiny_jiayi')
shiny::runApp('C:/Users/jia yi/Desktop/MITB/Sem2/ISSS608 Visual Analytics and its applications/Project/RShiny/ProjRShiny_jiayi')
View(pass_central)
passVol <- read_csv("data/passenger volume by busstop.csv")
passVol <- passVol %>% rename(BusStopCode = PT_CODE) %>%
group_by(BusStopCode) %>% summarise(frequencyIn = sum(TOTAL_TAP_IN_VOLUME),frequencyOut = sum(TOTAL_TAP_OUT_VOLUME))
# centrality dataset
central <- read_csv("data/centralityTable.csv")
central$BusStopCode <- as.character(central$BusStopCode)
pass_central <- inner_join(passVol, central, by = "BusStopCode")
setwd("C:/Users/jia yi/Desktop/MITB/Sem2/ISSS608 Visual Analytics and its applications/Project/RShiny/ProjRShiny_jiayi")
passVol <- read_csv("data/passenger volume by busstop.csv")
passVol <- passVol %>% rename(BusStopCode = PT_CODE) %>%
group_by(BusStopCode) %>% summarise(frequencyIn = sum(TOTAL_TAP_IN_VOLUME),frequencyOut = sum(TOTAL_TAP_OUT_VOLUME))
# centrality dataset
central <- read_csv("data/centralityTable.csv")
central$BusStopCode <- as.character(central$BusStopCode)
pass_central <- inner_join(passVol, central, by = "BusStopCode")
pass_central <- inner_join(passVol, central, by = "BusStopCode") %>%
rename(c(closeness, between,eigen,degree) = c(closeness.f, between.f,eigen.f,degree.f))
pass_central <- inner_join(passVol, central, by = "BusStopCode") %>%
rename(closeness=closeness.f, between=between.f,eigen=eigen.f,degree=degree.f)
y_tap <- lm(frequencyIn~ closeness + between + degree + eigen, data = pass_central)
step <- stepAIC(y_tap, direction = "both")
runApp()
runApp()
runApp()
runApp()
install.packages("MASS")
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
